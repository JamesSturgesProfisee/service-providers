{
  "artifactVersion": "1.5.1.0",
  "scripts": [
    {
      "Configuration": {
        "scriptContent": "import { fetch } from \"Profisee\";\n\nconst ASSET_TYPE_ID_CODE_VALUE = \"00000000-0000-0000-0000-000000021001\";\nconst ASSET_TYPE_ID_CODE_SET   = \"00000000-0000-0000-0000-000000021002\";\n\nconst DOMAIN_TYPE_ID_CODELIST = \"00000000-0000-0000-0000-000000020001\";\n\nconst RELATION_TYPE_ID_CODEVALUE_IN_CODESET = \"00000000-0000-0000-0000-000000007041\";\n\nconst ATTRIBUTE_TYPE_ID_DESCRIPTION = \"00000000-0000-0000-0000-000000003114\";\nconst ATTRIBUTE_TYPE_NAME_SYSTEM = \"System\";\n\nconst ATTRIBUTE_TYPE_NAME_SOURCE = \"Source\";\nconst ATTRIBUTE_TYPE_NAME_VALUE_SET_ID = \"Value Set ID\";\n\nconst TRANSACTION_TYPE_MAP = {\n  1: \"create\",\n  2: \"update\",\n  3: \"delete\"\n};\n\nfunction utf8Bytes(str) {\n  const bytes = [];\n  for (let i = 0; i < str.length; i++) {\n    let codePoint = str.charCodeAt(i);\n    if (codePoint >= 0xD800 && codePoint <= 0xDBFF && i + 1 < str.length) {\n      const next = str.charCodeAt(i + 1);\n      if (next >= 0xDC00 && next <= 0xDFFF) {\n        codePoint = 0x10000 + ((codePoint - 0xD800) << 10) + (next - 0xDC00);\n        i++;\n      }\n    }\n    if (codePoint <= 0x7F) {\n      bytes.push(codePoint);\n    } else if (codePoint <= 0x7FF) {\n      bytes.push(0xC0 | (codePoint >> 6));\n      bytes.push(0x80 | (codePoint & 0x3F));\n    } else if (codePoint <= 0xFFFF) {\n      bytes.push(0xE0 | (codePoint >> 12));\n      bytes.push(0x80 | ((codePoint >> 6) & 0x3F));\n      bytes.push(0x80 | (codePoint & 0x3F));\n    } else {\n      bytes.push(0xF0 | (codePoint >> 18));\n      bytes.push(0x80 | ((codePoint >> 12) & 0x3F));\n      bytes.push(0x80 | ((codePoint >> 6) & 0x3F));\n      bytes.push(0x80 | (codePoint & 0x3F));\n    }\n  }\n  return bytes;\n}\n\nfunction base64FromBytes(bytes) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  let out = \"\";\n  for (let i = 0; i < bytes.length; i += 3) {\n    const b1 = bytes[i];\n    const b2 = i + 1 < bytes.length ? bytes[i + 1] : 0;\n    const b3 = i + 2 < bytes.length ? bytes[i + 2] : 0;\n    const triplet = (b1 << 16) | (b2 << 8) | b3;\n    const c1 = (triplet >> 18) & 0x3F;\n    const c2 = (triplet >> 12) & 0x3F;\n    const c3 = (triplet >> 6) & 0x3F;\n    const c4 = triplet & 0x3F;\n    out += chars.charAt(c1);\n    out += chars.charAt(c2);\n    out += (i + 1 < bytes.length) ? chars.charAt(c3) : \"=\";\n    out += (i + 2 < bytes.length) ? chars.charAt(c4) : \"=\";\n  }\n  return out;\n}\n\nfunction b64EncodeUtf8(str) {\n  return base64FromBytes(utf8Bytes(str));\n}\n\nfunction normalizeBaseUrl(baseUrl) {\n  if (!baseUrl) return \"\";\n  return baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n}\n\nfunction parseJsonSafe(body) {\n  if (!body) return null;\n  try { return JSON.parse(body); } catch { return { raw: body }; }\n}\n\nfunction httpJson(baseUrl, authHeader, method, path, bodyObj) {\n  const url = `${baseUrl}${path}`;\n  const options = {\n    method,\n    headers: {\n      \"Authorization\": authHeader,\n      \"Accept\": \"application/json\",\n      \"Content-Type\": \"application/json\"\n    }\n  };\n  if (bodyObj !== undefined && bodyObj !== null) {\n    options.body = JSON.stringify(bodyObj);\n  }\n\n  const res = fetch(url, options);\n\n  // Network exception (Connect fetch captures exceptions on the response object)\n  if (res.exceptionType) {\n    return {\n      ok: false,\n      status: res.status || 0,\n      error: res.error || `Request failed calling ${method} ${path}`,\n      body: res.body || \"\",\n      json: null\n    };\n  }\n\n  const json = parseJsonSafe(res.body);\n  if (!res.ok) {\n    return {\n      ok: false,\n      status: res.status,\n      error: `HTTP ${res.status} calling ${method} ${path}: ${res.body}`,\n      body: res.body || \"\",\n      json\n    };\n  }\n\n  // Avoid retaining duplicate raw payload on successful calls.\n  return { ok: true, status: res.status, error: \"\", body: \"\", json };\n}\n\nfunction findFirstId(resultsContainer) {\n  return resultsContainer && resultsContainer.results && resultsContainer.results.length > 0\n    ? resultsContainer.results[0].id\n    : null;\n}\n\nfunction getCommunityId(baseUrl, authHeader, communityName) {\n  const r = httpJson(baseUrl, authHeader, \"GET\",\n    `/rest/2.0/communities?name=${encodeURIComponent(communityName)}&nameMatchMode=EXACT&limit=1`);\n  if (!r.ok) throw new Error(r.error);\n  return findFirstId(r.json);\n}\n\nfunction getDomainId(baseUrl, authHeader, communityId, domainName) {\n  const r = httpJson(baseUrl, authHeader, \"GET\",\n    `/rest/2.0/domains?communityId=${encodeURIComponent(communityId)}&name=${encodeURIComponent(domainName)}&nameMatchMode=EXACT&limit=1`);\n  if (!r.ok) throw new Error(r.error);\n  return findFirstId(r.json);\n}\n\nfunction createDomain(baseUrl, authHeader, communityId, domainName) {\n  const r = httpJson(\n    baseUrl,\n    authHeader,\n    \"POST\",\n    `/rest/2.0/domains`,\n    { name: domainName, typeId: DOMAIN_TYPE_ID_CODELIST, communityId }\n  );\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction findAssetIdInDomain(baseUrl, authHeader, domainId, assetName) {\n  const r = httpJson(baseUrl, authHeader, \"GET\",\n    `/rest/2.0/assets?domainId=${encodeURIComponent(domainId)}&name=${encodeURIComponent(assetName)}&nameMatchMode=EXACT&limit=1`);\n  if (!r.ok) throw new Error(r.error);\n  return findFirstId(r.json);\n}\n\nfunction getAssetById(baseUrl, authHeader, assetId) {\n  const r = httpJson(baseUrl, authHeader, \"GET\", `/rest/2.0/assets/${encodeURIComponent(assetId)}`);\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction getAssetDomainId(asset) {\n  if (!asset) return \"\";\n  if (asset.domain && typeof asset.domain === \"object\" && asset.domain.id) return asset.domain.id;\n  if (asset.domainId) return asset.domainId;\n  if (typeof asset.domain === \"string\") return asset.domain;\n  return \"\";\n}\n\nfunction createAsset(baseUrl, authHeader, name, displayName, domainId, typeId) {\n  const r = httpJson(baseUrl, authHeader, \"POST\", `/rest/2.0/assets`, { name: name, displayName: displayName, typeId: typeId, domainId: domainId });\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction updateAsset(baseUrl, authHeader, assetId, fields) {\n  const r = httpJson(baseUrl, authHeader, \"PATCH\", `/rest/2.0/assets/${encodeURIComponent(assetId)}`, fields);\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction deleteAsset(baseUrl, authHeader, assetId) {\n  const r = httpJson(baseUrl, authHeader, \"DELETE\", `/rest/2.0/assets/${encodeURIComponent(assetId)}`);\n  if (!r.ok) throw new Error(r.error);\n  return true;\n}\n\nfunction upsertCodeSetAsset(baseUrl, authHeader, domainId, codeSetName) {\n  const existingId = findAssetIdInDomain(baseUrl, authHeader, domainId, codeSetName);\n  if (existingId) {\n    return { id: existingId, created: false, updated: false };\n  }\n\n  const created = createAsset(baseUrl, authHeader, codeSetName, codeSetName, domainId, ASSET_TYPE_ID_CODE_SET);\n  const createdId = created && created.id ? created.id : \"\";\n  return { id: createdId, created: true, updated: false };\n}\n\nfunction upsertCodeValueAsset(baseUrl, authHeader, domainId, codeValueName, codeValueDisplayName, codeValueIds, explicitCodeValueId) {\n  const codeValueKey = `${domainId}::${codeValueName}`;\n  const normalizedId = explicitCodeValueId ? String(explicitCodeValueId).trim() : \"\";\n\n  if (normalizedId) {\n    const existingAsset = getAssetById(baseUrl, authHeader, normalizedId);\n    const existingDomainId = getAssetDomainId(existingAsset);\n    if (!existingDomainId) {\n      throw new Error(`Could not determine domain for collibraAssetId: ${normalizedId}`);\n    }\n    if (existingDomainId !== domainId) {\n      throw new Error(`collibraAssetId ${normalizedId} is in domain ${existingDomainId}, expected ${domainId}`);\n    }\n\n    if (codeValueDisplayName) {\n      updateAsset(baseUrl, authHeader, normalizedId, { displayName: codeValueDisplayName });\n    }\n    codeValueIds[codeValueKey] = normalizedId;\n    return { id: normalizedId, created: false, updated: Boolean(codeValueDisplayName) };\n  }\n\n  let existingId = codeValueIds[codeValueKey];\n  if (!existingId) {\n    existingId = findAssetIdInDomain(baseUrl, authHeader, domainId, codeValueName);\n  }\n  if (existingId) {\n    if (codeValueDisplayName) {\n      updateAsset(baseUrl, authHeader, existingId, { displayName: codeValueDisplayName });\n    }\n    codeValueIds[codeValueKey] = existingId;\n    return { id: existingId, created: false, updated: Boolean(codeValueDisplayName) };\n  }\n\n  const displayName = codeValueDisplayName || codeValueName;\n  const created = createAsset(baseUrl, authHeader, codeValueName, displayName, domainId, ASSET_TYPE_ID_CODE_VALUE);\n  const createdId = created && created.id ? created.id : \"\";\n  if (createdId) {\n    codeValueIds[codeValueKey] = createdId;\n  }\n  return { id: createdId, created: true, updated: false };\n}\n\nfunction findRelationId(baseUrl, authHeader, typeId, sourceId, targetId) {\n  const r = httpJson(\n    baseUrl,\n    authHeader,\n    \"GET\",\n    `/rest/2.0/relations?typeId=${encodeURIComponent(typeId)}&sourceId=${encodeURIComponent(sourceId)}&targetId=${encodeURIComponent(targetId)}&limit=1`\n  );\n  if (!r.ok) throw new Error(r.error);\n  return findFirstId(r.json);\n}\n\nfunction createRelation(baseUrl, authHeader, typeId, sourceId, targetId) {\n  const r = httpJson(baseUrl, authHeader, \"POST\", `/rest/2.0/relations`, { typeId, sourceId, targetId });\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction codeSetHasCodeValues(baseUrl, authHeader, codeSetId) {\n  const r = httpJson(\n    baseUrl,\n    authHeader,\n    \"GET\",\n    `/rest/2.0/relations?typeId=${encodeURIComponent(RELATION_TYPE_ID_CODEVALUE_IN_CODESET)}&targetId=${encodeURIComponent(codeSetId)}&limit=1`\n  );\n  if (!r.ok) throw new Error(r.error);\n  return Boolean(r.json && r.json.results && r.json.results.length > 0);\n}\n\nfunction findAttributeId(baseUrl, authHeader, assetId, attrTypeId) {\n  const r = httpJson(\n    baseUrl,\n    authHeader,\n    \"GET\",\n    `/rest/2.0/attributes?assetId=${encodeURIComponent(assetId)}&typeIds=${encodeURIComponent(attrTypeId)}&limit=1`\n  );\n  if (!r.ok) throw new Error(r.error);\n  return findFirstId(r.json);\n}\n\nfunction createAttribute(baseUrl, authHeader, assetId, typeId, value) {\n  const r = httpJson(baseUrl, authHeader, \"POST\", `/rest/2.0/attributes`, { assetId, typeId, value });\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction updateAttribute(baseUrl, authHeader, attributeId, value) {\n  const r = httpJson(baseUrl, authHeader, \"PATCH\", `/rest/2.0/attributes/${encodeURIComponent(attributeId)}`, { value });\n  if (!r.ok) throw new Error(r.error);\n  return r.json;\n}\n\nfunction upsertAttribute(baseUrl, authHeader, assetId, attrTypeId, value) {\n  if (!attrTypeId || value === undefined || value === null || value === \"\") return;\n  const attrId = findAttributeId(baseUrl, authHeader, assetId, attrTypeId);\n  if (attrId) {\n    updateAttribute(baseUrl, authHeader, attrId, value);\n  } else {\n    createAttribute(baseUrl, authHeader, assetId, attrTypeId, value);\n  }\n}\n\nfunction getAttributeTypeIdByName(baseUrl, authHeader, attributeTypeName) {\n  if (!attributeTypeName) return \"\";\n\n  const r = httpJson(\n    baseUrl,\n    authHeader,\n    \"GET\",\n    `/rest/2.0/attributeTypes/name/${encodeURIComponent(attributeTypeName)}`\n  );\n\n  if (!r.ok) throw new Error(r.error);\n\n  return r.json && r.json.id ? r.json.id : \"\";\n}\n\nfunction resolveTransactionAction(transactionType) {\n  return TRANSACTION_TYPE_MAP[Number(transactionType)] || \"\";\n}\n\nfunction resolveCommunityId(state, communityName, required) {\n  let communityId = state.communityIds[communityName];\n  if (!communityId) {\n    communityId = getCommunityId(state.baseUrl, state.authHeader, communityName);\n    if (communityId) {\n      state.communityIds[communityName] = communityId;\n    }\n  }\n  if (!communityId && required) {\n    throw new Error(`Community not found: ${communityName}`);\n  }\n  return communityId || \"\";\n}\n\nfunction resolveDomainId(state, communityId, domainName, createIfMissing) {\n  const domainKey = `${communityId}::${domainName}`;\n  let domainId = state.domainIds[domainKey];\n\n  if (!domainId) {\n    domainId = getDomainId(state.baseUrl, state.authHeader, communityId, domainName);\n    if (!domainId && createIfMissing) {\n      const createdDomain = createDomain(state.baseUrl, state.authHeader, communityId, domainName);\n      domainId = createdDomain && createdDomain.id ? createdDomain.id : \"\";\n      if (!domainId) {\n        throw new Error(`Failed to create Domain: ${domainName}`);\n      }\n    }\n\n    if (domainId) {\n      state.domainIds[domainKey] = domainId;\n    }\n  }\n\n  return domainId || \"\";\n}\n\nfunction resolveCodeSetId(state, domainId, codeSetName, createIfMissing) {\n  const codeSetKey = `${domainId}::${codeSetName}`;\n  let codeSetId = state.codeSetIds[codeSetKey];\n\n  if (!codeSetId) {\n    if (createIfMissing) {\n      const codeSetUpsert = upsertCodeSetAsset(state.baseUrl, state.authHeader, domainId, codeSetName);\n      codeSetId = codeSetUpsert.id;\n      if (!codeSetId) {\n        throw new Error(`Failed to upsert Code Set asset: ${codeSetName}`);\n      }\n    } else {\n      codeSetId = findAssetIdInDomain(state.baseUrl, state.authHeader, domainId, codeSetName);\n    }\n\n    if (codeSetId) {\n      state.codeSetIds[codeSetKey] = codeSetId;\n    }\n  }\n\n  return codeSetId || \"\";\n}\n\nfunction ensureUpsertMetadata(state) {\n  if (state.upsertMetadataLoaded) {\n    return;\n  }\n\n  state.sourceAttrTypeId = getAttributeTypeIdByName(state.baseUrl, state.authHeader, ATTRIBUTE_TYPE_NAME_SOURCE);\n  if (!state.sourceAttrTypeId) {\n    throw new Error(`Attribute type not found: ${ATTRIBUTE_TYPE_NAME_SOURCE}`);\n  }\n\n  state.valueSetIdAttributeTypeId = getAttributeTypeIdByName(state.baseUrl, state.authHeader, ATTRIBUTE_TYPE_NAME_VALUE_SET_ID);\n\n  state.systemAttrTypeId = getAttributeTypeIdByName(state.baseUrl, state.authHeader, ATTRIBUTE_TYPE_NAME_SYSTEM);\n  if (!state.systemAttrTypeId) {\n    throw new Error(`Attribute type not found: ${ATTRIBUTE_TYPE_NAME_SYSTEM}`);\n  }\n\n  state.upsertMetadataLoaded = true;\n}\n\nfunction handleUpsertRecord(state, row) {\n  const codeValueName = row.codeValueName;\n  const codeValueDisplayName = row.codeValueDisplayName;\n  const collibraAssetId = row.collibraAssetId;\n  const description = row.description;\n  const system = row.system;\n  const communityName = row.communityName;\n  const domainName = row.domainName;\n  const codeSetName = row.codeSetName;\n  const source = row.source;\n  const valueSetIdAttributeValue = row.valueSetId;\n\n  if (!communityName) throw new Error(\"communityName is required\");\n  if (!domainName) throw new Error(\"domainName is required\");\n  if (!codeSetName) throw new Error(\"codeSetName is required\");\n  if (!codeValueName) throw new Error(\"codeValueName is required\");\n\n  ensureUpsertMetadata(state);\n\n  const communityId = resolveCommunityId(state, communityName, true);\n  const domainId = resolveDomainId(state, communityId, domainName, true);\n  const codeSetId = resolveCodeSetId(state, domainId, codeSetName, true);\n  const normalizedAssetId = collibraAssetId ? String(collibraAssetId).trim() : \"\";\n\n  const codeSetAttributeKey = `${codeSetId}::${source || \"\"}::${valueSetIdAttributeValue || \"\"}`;\n  if (!state.codeSetAttributeState[codeSetAttributeKey]) {\n    if (source) {\n      upsertAttribute(state.baseUrl, state.authHeader, codeSetId, state.sourceAttrTypeId, source);\n    }\n\n    if (valueSetIdAttributeValue) {\n      if (!state.valueSetIdAttributeTypeId) {\n        throw new Error(`Attribute type not found: ${ATTRIBUTE_TYPE_NAME_VALUE_SET_ID}`);\n      }\n      upsertAttribute(state.baseUrl, state.authHeader, codeSetId, state.valueSetIdAttributeTypeId, valueSetIdAttributeValue);\n    }\n\n    state.codeSetAttributeState[codeSetAttributeKey] = true;\n  }\n\n  const codeValueUpsert = upsertCodeValueAsset(\n    state.baseUrl,\n    state.authHeader,\n    domainId,\n    codeValueName,\n    codeValueDisplayName,\n    state.codeValueIds,\n    normalizedAssetId\n  );\n  const codeValueId = codeValueUpsert.id;\n  if (!codeValueId) throw new Error(\"Could not determine Code Value ID\");\n\n  const relationKey = `${codeValueId}::${codeSetId}`;\n  if (!state.ensuredRelations[relationKey]) {\n    const relId = findRelationId(\n      state.baseUrl,\n      state.authHeader,\n      RELATION_TYPE_ID_CODEVALUE_IN_CODESET,\n      codeValueId,\n      codeSetId\n    );\n    if (!relId) {\n      createRelation(state.baseUrl, state.authHeader, RELATION_TYPE_ID_CODEVALUE_IN_CODESET, codeValueId, codeSetId);\n    }\n    state.ensuredRelations[relationKey] = true;\n  }\n\n  if (description) {\n    upsertAttribute(state.baseUrl, state.authHeader, codeValueId, ATTRIBUTE_TYPE_ID_DESCRIPTION, description);\n  }\n\n  if (system) {\n    upsertAttribute(state.baseUrl, state.authHeader, codeValueId, state.systemAttrTypeId, system);\n  }\n\n  return {\n    codeValueName: codeValueName,\n    codeValueId: codeValueId,\n    codeUrl: `${state.baseUrl}/domain/${domainId}`\n  };\n}\n\nfunction handleDeleteRecord(state, row) {\n  const codeValueName = row.codeValueName;\n  const collibraAssetId = row.collibraAssetId;\n  const communityName = row.communityName;\n  const domainName = row.domainName;\n  const codeSetName = row.codeSetName;\n\n  if (!communityName) throw new Error(\"communityName is required\");\n  if (!domainName) throw new Error(\"domainName is required\");\n  if (!codeSetName) throw new Error(\"codeSetName is required\");\n  if (!codeValueName && !collibraAssetId) throw new Error(\"codeValueName or collibraAssetId is required\");\n\n  const communityId = resolveCommunityId(state, communityName, false);\n  if (!communityId) {\n    return { codeValueName: codeValueName || \"\", codeValueId: \"\", codeUrl: \"\" };\n  }\n\n  const domainId = resolveDomainId(state, communityId, domainName, false);\n  if (!domainId) {\n    return { codeValueName: codeValueName || \"\", codeValueId: \"\", codeUrl: \"\" };\n  }\n\n  const codeSetId = resolveCodeSetId(state, domainId, codeSetName, false);\n  const normalizedAssetId = collibraAssetId ? String(collibraAssetId).trim() : \"\";\n  const codeValueId = normalizedAssetId || findAssetIdInDomain(state.baseUrl, state.authHeader, domainId, codeValueName);\n\n  if (!codeValueId) {\n    return {\n      codeValueName: codeValueName || \"\",\n      codeValueId: \"\",\n      codeUrl: `${state.baseUrl}/domain/${domainId}`\n    };\n  }\n\n  deleteAsset(state.baseUrl, state.authHeader, codeValueId);\n\n  if (codeValueName) {\n    delete state.codeValueIds[`${domainId}::${codeValueName}`];\n  }\n  if (codeSetId) {\n    delete state.ensuredRelations[`${codeValueId}::${codeSetId}`];\n\n    const hasCodeValues = codeSetHasCodeValues(state.baseUrl, state.authHeader, codeSetId);\n    if (!hasCodeValues) {\n      deleteAsset(state.baseUrl, state.authHeader, codeSetId);\n      delete state.codeSetIds[`${domainId}::${codeSetName}`];\n    }\n  }\n\n  return {\n    codeValueName: codeValueName || \"\",\n    codeValueId: codeValueId,\n    codeUrl: `${state.baseUrl}/domain/${domainId}`\n  };\n}\n\nexport function execute(input) {\n  try {\n    const records = (input && input.records) ? input.records : [];\n\n    if (!records || records.length === 0) {\n      throw(\"No records\");\n    }\n\n    const baseUrl = normalizeBaseUrl(input.baseUrl);\n    const username = input.username;\n    //workaround for bug in 25.4. When 26.1 is released, revert this back to:\n    // const password = input.password\n    const password = (input.password && input.password.configuration && input.password.configuration.value !== undefined)\n      ? input.password.configuration.value\n      : input.password;\n    const rawBasic = String(username) + \":\" + String(password);\n    const encodedBasic = b64EncodeUtf8(rawBasic);\n    const authHeader = \"Basic \" + encodedBasic;\n\n    const state = {\n      baseUrl,\n      authHeader,\n      sourceAttrTypeId: \"\",\n      valueSetIdAttributeTypeId: \"\",\n      systemAttrTypeId: \"\",\n      upsertMetadataLoaded: false,\n      communityIds: {},\n      domainIds: {},\n      codeSetIds: {},\n      codeValueIds: {},\n      ensuredRelations: {},\n      codeSetAttributeState: {}\n    };\n\n    const outputRecords = [];\n\n    for (let i = 0; i < records.length; i++) {\n      const row = records[i] || {};\n\n      try {\n        const transactionAction = resolveTransactionAction(row.transactionType);\n        const outputRecord = transactionAction === \"delete\"\n          ? handleDeleteRecord(state, row)\n          : handleUpsertRecord(state, row);\n\n        outputRecords.push(outputRecord);\n      } catch (e) {\n        const msg = e && e.message ? e.message : String(e);\n        throw(`Row ${i} Error: ${msg}`);\n      }\n    }\n\n    return { isSuccess: true, records: outputRecords };\n  } catch (e) {\n    const msg = e && e.message ? e.message : String(e);\n    return { isSuccess: false, error: `ERROR: ${msg}`, records: [] };\n  }\n}\n"
      },
      "Id": "3e66f388-8579-4a5a-958b-c6e8a7c1e750",
      "Code": "3e66f388-8579-4a5a-958b-c6e8a7c1e750",
      "Name": "UpsertAssets"
    }
  ],
  "serviceProviderRecord": {
    "Configuration": {
      "workerQueueOptions": {
        "workerCount": 1,
        "priorityQueueThreshold": {
          "maxJobCount": 1,
          "maxRecordCount": 1000
        }
      },
      "services": {
        "UpsertAssets": {
          "name": "Upsert Assets",
          "description": "Upserts Domains, Code Sets, and Code Values to Collibra",
          "inputs": {
            "connection": {
              "scope": "Service",
              "friendlyName": "Connection Details",
              "presenterConfiguration": {
                "type": "ParameterSet",
                "settings": {
                  "Parameters": {
                    "Base URL": "baseUrl",
                    "Username": "username",
                    "Password": "password"
                  }
                }
              },
              "isRequired": false
            },
            "baseUrl": {
              "type": "String",
              "scope": "Service",
              "friendlyName": "Base URL",
              "presenterConfiguration": {
                "type": "String",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "username": {
              "type": "String",
              "scope": "Service",
              "friendlyName": "Username",
              "presenterConfiguration": {
                "type": "String",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "password": {
              "scope": "Service",
              "friendlyName": "Password",
              "presenterConfiguration": {
                "type": "Credential",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "communityName": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Community Name",
              "presenterConfiguration": {
                "type": "String",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "domainName": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Domain Name",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "codeSetName": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Code Set Name",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "valueSetId": {
              "scope": "Data",
              "type": "String",
              "friendlyName": "Value Set ID",
              "isRequired": true,
              "isReadOnly": false,
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              }
            },
            "source": {
              "scope": "Data",
              "type": "String",
              "friendlyName": "Source",
              "isRequired": true,
              "isReadOnly": false,
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              }
            },
            "codeValueName": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Code Value Name",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "collibraAssetId": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Collibra Asset ID",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": false,
              "isReadOnly": false
            },
            "codeValueDisplayName": {
              "scope": "Data",
              "type": "String",
              "friendlyName": "Code Value Display Name",
              "isRequired": false,
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              }
            },
            "description": {
              "type": "String",
              "scope": "Data",
              "friendlyName": "Description",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            },
            "system": {
              "scope": "Data",
              "type": "String",
              "friendlyName": "System",
              "isRequired": true,
              "isReadOnly": false,
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              }
            },
            "transactionType": {
              "type": "Integer",
              "scope": "Data",
              "friendlyName": "Transaction Type",
              "presenterConfiguration": {
                "type": "Expression",
                "settings": {}
              },
              "isRequired": true,
              "isReadOnly": false
            }
          },
          "outputs": {
            "codeValueName": {
              "name": "Name",
              "type": "String"
            },
            "codeValueId": {
              "name": "ID",
              "type": "String"
            },
            "codeUrl": {
              "name": "URL",
              "type": "String"
            }
          },
          "scriptId": "3e66f388-8579-4a5a-958b-c6e8a7c1e750",
          "maximumRecordsPerRequest": 100
        }
      }
    },
    "Id": "98d57a6a-2a41-4763-b0e7-b22b6c0899c6",
    "Code": "98d57a6a-2a41-4763-b0e7-b22b6c0899c6",
    "Name": "Collibra Service Provider",
    "Type": "Script"
  }
}